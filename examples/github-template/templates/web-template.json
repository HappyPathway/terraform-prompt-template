{"readme_content": "# FastAPI E-commerce API (HappyPathway)\n\nBuild a modern e-commerce backend API using Python FastAPI framework with PostgreSQL, Docker, and best security practices.\n\n## Overview\n\nThis project provides a robust and scalable backend solution for e-commerce platforms. It includes features for user management, product catalog management, and order processing, all built with a focus on performance, security, and maintainability using the latest industry standards.\n\n## Tech Stack\n\n- **Language & Framework**: Python 3.11+, FastAPI (e.g., 0.111.0)\n- **Database**: PostgreSQL (e.g., 16) with SQLAlchemy 2.0.x (e.g., 2.0.31) and Alembic (e.g., 1.13.1) for migrations. Async driver: `psycopg[binary,pool]` (e.g., 3.1.19).\n- **Authentication**: JWT with OAuth2 (`python-jose` e.g., 3.3.0, `passlib[bcrypt]` e.g., 1.7.4)\n- **Data Validation**: Pydantic V2\n- **Deployment**: Docker, Docker Compose, GitHub Actions\n- **Testing**: Pytest (e.g., 8.2.2), `pytest-asyncio` (e.g., 0.23.7), `httpx` (e.g., 0.27.0), `pytest-cov` (e.g., 5.0.0)\n- **Linting/Formatting/Type Checking**: Ruff (e.g., 0.4.10), Mypy (e.g., 1.10.0)\n- **ASGI Server**: Uvicorn (e.g., 0.30.1)\n- **Payment Integration**: Stripe SDK (e.g., 9.10.0)\n\n## Core Features\n\n### User Management\n- User authentication (login/register) with JWT.\n- Secure password hashing using bcrypt.\n- Role-based permissions (to be implemented based on roles defined in models).\n- User profile management.\n\n### Product Management\n- Full CRUD operations for products.\n- Product categorization and tagging.\n- Advanced search and filtering capabilities.\n- Real-time inventory tracking.\n\n### Order Processing\n- Secure order creation and detailed tracking.\n- Integration with Stripe for payment processing.\n- Comprehensive order history for users.\n\n### API Documentation\n- Automatic interactive API documentation via Swagger UI (`/docs`).\n- Alternative API documentation via ReDoc (`/redoc`).\n- Comprehensive Pydantic models and endpoint docstrings for clarity.\n\n## Project Structure\n\n```\napp/\n\u251c\u2500\u2500 api/           # API endpoints (routers for different modules)\n\u2502   \u251c\u2500\u2500 deps.py    # Dependency injection functions (e.g., get_db, get_current_user)\n\u2502   \u2514\u2500\u2500 routes/    # Routers for auth, users, products, orders\n\u2502       \u251c\u2500\u2500 auth.py\n\u2502       \u251c\u2500\u2500 users.py\n\u2502       \u251c\u2500\u2500 products.py\n\u2502       \u2514\u2500\u2500 orders.py\n\u251c\u2500\u2500 core/          # Core logic, configuration, security\n\u2502   \u251c\u2500\u2500 config.py  # Application settings (Pydantic BaseSettings)\n\u2502   \u2514\u2500\u2500 security.py# JWT handling, password hashing, OAuth2 schemes\n\u251c\u2500\u2500 db/            # Database interaction layer\n\u2502   \u251c\u2500\u2500 base.py    # Base model (declarative_base) and session management (async_sessionmaker)\n\u2502   \u251c\u2500\u2500 models.py  # SQLAlchemy ORM models (e.g., user.py, product.py, order.py)\n\u2502   \u251c\u2500\u2500 schemas.py # Pydantic schemas for request/response validation (e.g., user_schemas.py)\n\u2502   \u2514\u2500\u2500 migrations/ # Alembic migration scripts (generated)\n\u2502       \u2514\u2500\u2500 versions/\n\u251c\u2500\u2500 services/      # Business logic layer (CRUD operations, complex logic)\n\u2502   \u251c\u2500\u2500 user_service.py\n\u2502   \u251c\u2500\u2500 product_service.py\n\u2502   \u2514\u2500\u2500 order_service.py\n\u2514\u2500\u2500 main.py        # FastAPI application entry point and global configurations\n\ntests/             # Test suite (unit, integration, e2e)\n\u251c\u2500\u2500 conftest.py    # Pytest fixtures (e.g., db_session, async_client)\n\u251c\u2500\u2500 integration/   # Integration tests for API endpoints\n\u2514\u2500\u2500 unit/          # Unit tests for services, utilities\n\n.env.example       # Example environment variables\n.gitignore\nalembic.ini        # Alembic configuration\nDockerfile         # Container definition for production\ndocker-compose.yml # Local development environment setup\npoetry.lock        # Poetry lock file (if using Poetry)\npyproject.toml     # Project metadata and dependencies (Poetry or PEP 621)\nREADME.md\n```\n\n## Prerequisites\n\n- Python 3.11+\n- Docker and Docker Compose (latest versions recommended)\n- Poetry (recommended for dependency management) or pip\n- Access to a PostgreSQL instance (Dockerized instance provided in `docker-compose.yml`)\n- Stripe account and API keys (for payment integration)\n\n## Getting Started\n\n### 1. Clone the Repository\n\n```bash\ngit clone <repository-url>\ncd fastapi-ecommerce-api\n```\n\n### 2. Environment Configuration\n\nCopy the example environment file and update it with your settings:\n\n```bash\ncp .env.example .env\n```\n\nEdit `.env` with your database credentials, JWT secret, Stripe keys, etc.\nKey variables:\n- `PROJECT_NAME=\"FastAPI E-commerce API\"`\n- `API_V1_STR=\"/api/v1\"` (Example for API versioning)\n- `DATABASE_URL=\"postgresql+asyncpg://user:password@host:port/dbname\"` (e.g., `postgresql+asyncpg://postgres:changethis@localhost:5432/app` for local Docker setup)\n- `SECRET_KEY` (A strong, random string for JWT encoding)\n- `ALGORITHM=\"HS256\"`\n- `ACCESS_TOKEN_EXPIRE_MINUTES=30`\n- `STRIPE_SECRET_KEY=\"sk_test_yourkey\"`\n- `STRIPE_PUBLISHABLE_KEY=\"pk_test_yourkey\"`\n- `ENVIRONMENT=\"dev\"` (e.g., dev, prod, test)\n\n### 3. Using Docker (Recommended for Local Development)\n\nThis is the easiest way to get started.\n\n```bash\n# Build and start the containers (API, DB)\ndocker-compose up --build -d\n\n# View logs for the application container\ndocker-compose logs -f app\n\n# Apply database migrations (run this after the DB container is healthy)\ndocker-compose exec app alembic upgrade head\n```\nThe API will be available at `http://localhost:8000` (or the port specified in `docker-compose.yml`).\nSwagger docs: `http://localhost:8000/docs`\nReDoc: `http://localhost:8000/redoc`\n\n### 4. Manual Setup (without Docker, using Poetry)\n\nEnsure you have Python 3.11+ and Poetry installed.\n\n```bash\n# Install dependencies\npoetry install\n\n# Activate virtual environment\npoetry shell\n\n# Set up PostgreSQL database manually or ensure it's accessible.\n# Update .env with your database connection string.\n\n# Run database migrations\n# Ensure your .env is loaded or DATABASE_URL is otherwise available\nalembic upgrade head\n\n# Run the application\nuvicorn app.main:app --reload --host 0.0.0.0 --port 8000\n```\n\n## Running Tests\n\nTests are run using Pytest. Ensure your test database is configured (often a separate database or schema, managed via test setup/teardown).\n\nUsing Docker:\n```bash\n# Ensure containers are running\ndocker-compose exec app pytest tests/\n```\n\nLocally (with Poetry):\n```bash\n# Ensure .env is configured for the test environment if needed\npoetry run pytest tests/\n```\nTo include coverage report:\n```bash\npoetry run pytest --cov=app --cov-report=html --cov-report=term tests/\n# Open htmlcov/index.html to view the HTML report\n```\n\n## Key Endpoints (Example - refer to `/docs` for full details)\n\nBase URL: `/api` (or `/api/v1` if versioned)\n\n### Auth (`/api/auth`)\n- `POST /login`: User login, returns JWT.\n- `POST /register`: New user registration.\n\n### Users (`/api/users`)\n- `GET /me`: Get current authenticated user's profile.\n- `PUT /me`: Update current authenticated user's profile.\n- `GET /{user_id}`: Get user details (admin only).\n- `PUT /{user_id}`: Update user (admin only).\n\n### Products (`/api/products`)\n- `GET /`: List all products with pagination, filtering, and search.\n- `POST /`: Create a new product (admin/privileged user).\n- `GET /{product_id}`: Get a specific product.\n- `PUT /{product_id}`: Update a product (admin/privileged user).\n- `DELETE /{product_id}`: Delete a product (admin/privileged user).\n\n### Orders (`/api/orders`)\n- `POST /`: Create a new order.\n- `GET /`: List orders for the authenticated user (or all orders for admin).\n- `GET /{order_id}`: Get details of a specific order.\n- `PUT /{order_id}/status`: Update order status (admin/privileged user).\n\n## Database Migrations (Alembic)\n\nAlembic is used for managing database schema changes.\n\n- **Generate a new migration script:**\n  After making changes to your SQLAlchemy models in `app/db/models.py`:\n  ```bash\n  # Using Docker\n  docker-compose exec app alembic revision -m \"your_migration_message\"\n  # Locally (with Poetry and venv activated)\n  alembic revision -m \"your_migration_message\"\n  ```\n  Then, carefully review and edit the generated script in `app/db/migrations/versions/`.\n\n- **Apply migrations to the database:**\n  ```bash\n  # Using Docker\n  docker-compose exec app alembic upgrade head\n  # Locally\n  alembic upgrade head\n  ```\n\n- **Downgrade migrations:**\n  ```bash\n  # Using Docker\n  docker-compose exec app alembic downgrade -1 # Downgrade by one revision\n  # docker-compose exec app alembic downgrade base # Downgrade all migrations\n  # Locally\n  alembic downgrade -1\n  ```\n\n## Security Best Practices Implemented\n\n- **HTTPS**: Enforced in production environments (typically via a reverse proxy like Nginx or Traefik).\n- **JWT Authentication**: Secure token-based authentication with OAuth2 password flow and bearer tokens.\n- **Password Hashing**: `bcrypt` (via `passlib`) used for securely storing user passwords.\n- **Input Validation**: Pydantic models validate all incoming request data (bodies, query params, path params).\n- **SQLAlchemy ORM**: Helps prevent SQL injection vulnerabilities by parameterizing queries.\n- **Rate Limiting**: Recommended to be added (e.g., using `slowapi` or a gateway-level limiter).\n- **CORS (Cross-Origin Resource Sharing)**: Configured in `app/main.py` using `CORSMiddleware` to specify allowed origins, methods, and headers.\n- **Dependency Management & Vulnerability Scanning**: Regularly update dependencies using `poetry update` and consider tools like Dependabot or Snyk for vulnerability scanning.\n- **Secrets Management**: All sensitive data (API keys, database URLs, secret keys) managed via environment variables. Use Pydantic's `BaseSettings` in `app/core/config.py` to load these.\n- **Least Privilege**: Ensure API endpoints enforce appropriate permissions (e.g., only admins can access certain user management endpoints).\n\n## CI/CD Pipeline (GitHub Actions)\n\nA basic CI/CD pipeline is typically set up using GitHub Actions (see `.github/workflows/`). Common stages include:\n- **Linting & Formatting**: Run Ruff to check code style and formatting.\n- **Static Type Checking**: Run Mypy to catch type errors.\n- **Testing**: Execute the Pytest suite against various Python versions.\n- **Building Docker Image**: Build and push the Docker image to a container registry (e.g., Docker Hub, GitHub Container Registry).\n- **Deployment**: (Optional) Automate deployment to staging/production environments upon successful builds on specific branches.\n\n## Contributing\n\nPlease create a `CONTRIBUTING.md` file with guidelines for code style (e.g., enforce Ruff, Mypy), commit message conventions (e.g., Conventional Commits), and the process for submitting pull requests (fork, feature branch, PR against main/develop, code review requirements).\n\n## License\n\nThis project is licensed under the MIT License. Please create a `LICENSE` file with the MIT License text.", "best_practices": ["Async Everywhere: Utilize `async/await` for all I/O-bound operations (database, external APIs) using SQLAlchemy 2.0+ async capabilities and `httpx` for external calls.", "Robust Data Validation with Pydantic V2: Leverage Pydantic V2 for request/response validation, settings management, and data serialization, ensuring type safety and clear error messages.", "Comprehensive Testing with Pytest: Implement unit, integration, and end-to-end tests. Use `pytest-asyncio` for async code and aim for high code coverage. Test edge cases, validation, and security.", "Secure by Design: Implement JWT with OAuth2, use `passlib[bcrypt]` for password hashing, validate all inputs, protect against OWASP Top 10, and manage secrets via environment variables. Regularly update dependencies.", "Modular Project Structure: Adhere to the defined project structure (`app/api`, `app/core`, `app/db`, `app/services`) for better organization, maintainability, and separation of concerns.", "Efficient Database Operations: Use SQLAlchemy 2.0 (e.g., 2.0.31) with Alembic for migrations. Optimize queries, manage transactions carefully, and use connection pooling with `psycopg[binary,pool]` (3.x).", "Containerization and CI/CD: Use Docker for consistent development and deployment environments. Implement a CI/CD pipeline (e.g., GitHub Actions) for automated testing, linting, building, and deployment.", "Modern Python Tooling: Employ Python 3.11+, Ruff (e.g., 0.4.10) for linting and formatting, Mypy (e.g., 1.10.0) for static type checking, and pre-commit hooks to maintain code quality.", "Clear API Design & Documentation: Follow RESTful principles, use FastAPI's automatic OpenAPI/Swagger documentation, and ensure comprehensive docstrings for all endpoints and models.", "Effective Configuration Management: Use environment variables for all configurable parameters, especially secrets. Pydantic's `BaseSettings` is highly recommended for this."], "suggested_extensions": ["ms-python.python", "ms-python.vscode-pylance", "charliermarsh.ruff", "ms-azuretools.vscode-docker", "ms-ossdata.vscode-postgresql", "humao.rest-client", "GitHub.copilot", "tamasfe.even-better-toml", "VisualStudioExptTeam.vscodeintellicode"], "documentation_source": ["FastAPI Official Documentation: https://fastapi.tiangolo.com/", "Pydantic V2 Documentation: https://docs.pydantic.dev/latest/", "SQLAlchemy 2.0 Documentation (including async): https://docs.sqlalchemy.org/en/20/", "Alembic Documentation: https://alembic.sqlalchemy.org/en/latest/", "PostgreSQL Official Documentation: https://www.postgresql.org/docs/current/", "Psycopg 3 (Async PostgreSQL Driver): https://www.psycopg.org/psycopg3/docs/", "Pytest Official Documentation: https://docs.pytest.org/en/stable/", "Docker Official Documentation: https://docs.docker.com/", "Stripe API Documentation: https://stripe.com/docs/api", "Stripe Python Library: https://github.com/stripe/stripe-python", "Python-jose (JWT): https://python-jose.readthedocs.io/en/latest/", "Passlib (Password Hashing): https://passlib.readthedocs.io/en/stable/", "Ruff Linter/Formatter: https://docs.astral.sh/ruff/", "Mypy (Static Typing): https://mypy.readthedocs.io/en/stable/", "GitHub Actions Documentation: https://docs.github.com/en/actions"], "copilot_instructions": "# GitHub Copilot Instructions for fastapi-ecommerce-api (HappyPathway)\n\n## Project Overview\nYou are assisting with the development of a FastAPI-based e-commerce API. Key technologies include Python 3.11+, FastAPI (e.g., 0.111.0), Pydantic V2, SQLAlchemy 2.0 (e.g., 2.0.31) (async), PostgreSQL, Alembic (e.g., 1.13.1), Pytest (e.g., 8.2.2), Docker, and Stripe integration (e.g., stripe SDK 9.10.0).\n\n## Core Principles to Follow\n1.  **Async First**: Prioritize `async def` for route handlers, service functions, and database operations. Use `await` for all I/O-bound calls.\n2.  **Pydantic for Everything Data**:\n    *   Use Pydantic models for request bodies, query parameters, and response models.\n    *   Utilize Pydantic V2 features (e.g., `model_validate`, `field_validator`).\n    *   Define clear schemas in `app/db/schemas.py`.\n3.  **SQLAlchemy 2.0 Async**:\n    *   Use `AsyncSession` for database interactions with `psycopg` async driver.\n    *   Employ SQLAlchemy ORM models defined in `app/db/models.py`.\n    *   For queries, use `select()`, `await session.execute()`, `scalars().all()`, `scalar_one_or_none()`, etc.\n    *   Example:\n        ```python\n        from sqlalchemy import select\n        # ...\n        result = await session.execute(select(User).where(User.id == user_id))\n        user = result.scalar_one_or_none()\n        ```\n4.  **Dependency Injection**: Use FastAPI's `Depends` for database sessions, current user, and other dependencies. Define common dependencies in `app/api/deps.py`.\n5.  **Service Layer**: Encapsulate business logic within service functions in `app/services/`. API routes should primarily call these services.\n6.  **Error Handling**: Use FastAPI's `HTTPException` for standard errors. Implement custom exception handlers for application-specific errors if needed.\n7.  **Security**:\n    *   For authenticated endpoints, use `Depends(get_current_user)` (defined in `app.core.security` or `app.api.deps`).\n    *   Implement role-based access control where necessary.\n    *   Sanitize inputs (Pydantic helps) and be mindful of security best practices (OWASP Top 10).\n8.  **Testing**:\n    *   Write Pytest tests for all new features in the `tests/` directory.\n    *   Use `pytest-asyncio` for async tests.\n    *   Use `httpx.AsyncClient` for integration tests against the API.\n    *   Mock dependencies appropriately using `unittest.mock` or pytest fixtures.\n9.  **Configuration**: Use `app.core.config.settings` (an instance of Pydantic `BaseSettings`) for accessing environment variables and application settings.\n10. **Modularity**: Keep routers in `app/api/routes/` and organize them by feature (e.g., `products.py`, `users.py`, `orders.py`, `auth.py`).\n\n## Specific Task Guidance\n\n### When creating new API endpoints:\n*   Place the router in the appropriate file under `app/api/routes/` (e.g., `app/api/routes/products.py`).\n*   Define request and response Pydantic schemas in `app/db/schemas.py`.\n*   Implement the core business logic in a corresponding service function in `app/services/` (e.g., `app/services/product_service.py`).\n*   Use dependency injection for database sessions (`AsyncSession = Depends(deps.get_db)`) and authentication (`current_user: models.User = Depends(deps.get_current_active_user)`).\n*   Add comprehensive docstrings for OpenAPI documentation, including summary, description, and details about parameters and responses.\n*   Example structure for a new route:\n    ```python\n    # In app/api/routes/items.py\n    from fastapi import APIRouter, Depends, HTTPException\n    from sqlalchemy.ext.asyncio import AsyncSession\n    from app.db import schemas, models # Assuming models are in app.db.models\n    from app.services import item_service # Assuming item_service.py exists\n    from app.api import deps # Assuming deps.py for dependencies\n\n    router = APIRouter()\n\n    @router.post(\"/\", response_model=schemas.Item, status_code=201)\n    async def create_item(\n        item_in: schemas.ItemCreate,\n        db: AsyncSession = Depends(deps.get_db),\n        current_user: models.User = Depends(deps.get_current_active_user)\n    ):\n        \"\"\"\n        Create a new item.\n\n        - **item_in**: Item data to create.\n        - **db**: Database session.\n        - **current_user**: Authenticated user performing the action.\n        \"\"\"\n        # Add logic to check user permissions if necessary\n        # For example: if not user_service.is_admin(current_user):\n        #     raise HTTPException(status_code=403, detail=\"Not authorized\")\n        return await item_service.create_item(db=db, item_in=item_in, owner_id=current_user.id)\n    ```\n\n### When working with database models (`app/db/models.py`):\n*   Ensure all models inherit from `Base` (from `app/db/base.py` or `app/db/base_class.py`).\n*   Define relationships clearly using `relationship` and `ForeignKey`.\n*   If you add or modify models, remember to generate an Alembic migration script (`alembic revision -m \"description\"`) and review/edit it.\n\n### When writing service functions (`app/services/`):\n*   Functions should be `async def`.\n*   Accept `AsyncSession` as an argument (e.g., `db: AsyncSession`).\n*   Perform database operations and encapsulate business logic.\n*   Return Pydantic schemas or ORM models as appropriate for the API layer to consume.\n*   Handle potential database errors or business logic exceptions gracefully, possibly raising custom exceptions to be caught by FastAPI error handlers.\n\n### When writing tests (`tests/`):\n*   Use the `async_client: httpx.AsyncClient` fixture for API tests.\n*   Use the `db_session: AsyncSession` fixture for tests requiring direct database access.\n*   Ensure tests are independent and cover success cases, error cases (e.g., 400, 401, 403, 404), and edge cases.\n*   Use `pytest.mark.asyncio` for async test functions.\n\n## Code Style\n*   Follow PEP 8 guidelines strictly.\n*   Use Ruff for linting and formatting (it will guide you, ensure it's integrated into your pre-commit hooks and editor).\n*   Use type hints extensively for all function signatures and variable declarations. Run Mypy for static type checking.\n\nBy following these guidelines, you can help Copilot generate code that is consistent with the project's architecture, secure, and maintainable."}