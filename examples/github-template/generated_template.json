{"readme_content": "\"\"\"\n# crm-webapp - HappyPathway\n\n## Project Overview\n\nCreate a web application for customer relationship management with a React frontend and Node.js backend.\n\n## Table of Contents\n\n- [Project Overview](#project-overview)\n- [Tech Stack](#tech-stack)\n- [Prerequisites](#prerequisites)\n- [Getting Started](#getting-started)\n  - [Backend Setup](#backend-setup)\n  - [Frontend Setup](#frontend-setup)\n- [Running the Application](#running-the-application)\n  - [Backend](#backend)\n  - [Frontend](#frontend)\n- [Scripts](#scripts)\n- [Project Structure](#project-structure)\n  - [Backend Structure (Node.js/Express.js)](#backend-structure-nodejsexpressjs)\n  - [Frontend Structure (React/Vite)](#frontend-structure-reactvite)\n- [API Documentation](#api-documentation)\n- [State Management (Frontend)](#state-management-frontend)\n- [Styling (Frontend)](#styling-frontend)\n- [Testing](#testing)\n- [Linting and Formatting](#linting-and-formatting)\n- [Environment Variables](#environment-variables)\n- [Deployment](#deployment)\n- [Contributing](#contributing)\n- [Best Practices](#best-practices)\n- [Further Help & Documentation](#further-help--documentation)\n\n## Tech Stack\n\n**Frontend:**\n- React (v18.x)\n- Vite (v5.x) - Build Tool\n- React Router (v6.x) - Routing\n- Zustand or Redux Toolkit - State Management\n- Tailwind CSS (v3.x) or Material-UI (v5.x) - Styling\n- Axios - HTTP Client\n- Jest & React Testing Library - Testing\n- TypeScript\n\n**Backend:**\n- Node.js (LTS version, e.g., v20.x or v22.x)\n- Express.js (v4.x) or NestJS (v10.x) - Framework\n- Prisma (v5.x) or Mongoose - ORM/ODM\n- PostgreSQL or MongoDB - Database\n- JWT (JSON Web Tokens) for authentication\n- Jest & Supertest - Testing\n- TypeScript\n- Helmet - Security Headers\n- Morgan - HTTP request logger\n- Winston/Pino - Logging\n- Swagger/OpenAPI - API Documentation\n\n**Common:**\n- Git & GitHub - Version Control\n- npm (v10.x+) or Yarn (v1.22.x+ or Berry) - Package Manager\n- ESLint & Prettier - Linting & Formatting\n- Docker - Containerization (Optional but Recommended)\n- GitHub Actions - CI/CD\n\n## Prerequisites\n\n- Node.js (LTS version - check `.nvmrc` if present)\n- npm or Yarn\n- Git\n- Docker (Optional)\n- Access to a PostgreSQL or MongoDB instance\n\n## Getting Started\n\n1.  **Clone the repository:**\n    ```bash\n    git clone <repository-url>\n    cd crm-webapp\n    ```\n\n2.  **Install common tools (if not already installed):**\n    ```bash\n    # Example: Install ESLint and Prettier globally or as dev dependencies\n    npm install -g eslint prettier # or use local versions\n    ```\n\n### Backend Setup\n\n1.  **Navigate to the backend directory:**\n    ```bash\n    cd backend # Assuming a monorepo or separate backend folder\n    ```\n\n2.  **Install dependencies:**\n    ```bash\n    npm install\n    # or\n    yarn install\n    ```\n\n3.  **Set up environment variables:**\n    Create a `.env` file in the `backend` directory. See `.env.example` for required variables (e.g., `DATABASE_URL`, `JWT_SECRET`, `PORT`).\n    Example `.env.example`:\n    ```\n    PORT=3001\n    DATABASE_URL=\"postgresql://user:password@host:port/database?schema=public\" # Or MongoDB connection string\n    JWT_SECRET=\"your-super-secret-key\"\n    NODE_ENV=\"development\"\n    ```\n\n4.  **Database Setup (if using Prisma):**\n    ```bash\n    npx prisma migrate dev --name init # To create and apply migrations\n    npx prisma generate # To generate Prisma Client\n    # (Optional) Seed the database:\n    # npx prisma db seed\n    ```\n\n### Frontend Setup\n\n1.  **Navigate to the frontend directory:**\n    ```bash\n    cd ../frontend # Assuming a monorepo or separate frontend folder\n    ```\n\n2.  **Install dependencies:**\n    ```bash\n    npm install\n    # or\n    yarn install\n    ```\n\n3.  **Set up environment variables:**\n    Create a `.env` file in the `frontend` directory. See `.env.example` for required variables (e.g., `VITE_API_BASE_URL`).\n    Example `.env.example`:\n    ```\n    VITE_API_BASE_URL=\"http://localhost:3001/api\"\n    ```\n\n## Running the Application\n\n### Backend\n\n```bash\ncd backend\nnpm run dev # Or your configured development script (e.g., using nodemon)\n```\nThe backend will typically run on `http://localhost:3001` (or as configured in `.env`).\n\n### Frontend\n\n```bash\ncd frontend\nnpm run dev # For Vite\n```\nThe frontend will typically run on `http://localhost:5173` (Vite default) or `http://localhost:3000` (CRA default).\n\n## Scripts\n\nCommon scripts (add more as needed in `package.json` files):\n\n**Backend (`backend/package.json`):**\n- `npm run dev`: Start the development server (e.g., with nodemon).\n- `npm start`: Start the production server.\n- `npm run build`: Build the project (e.g., transpile TypeScript to JavaScript).\n- `npm test`: Run tests.\n- `npm run lint`: Run linter.\n- `npm run format`: Format code.\n- `npm run db:migrate:dev`: (Prisma) Apply development migrations.\n- `npm run db:generate`: (Prisma) Generate Prisma client.\n\n**Frontend (`frontend/package.json`):**\n- `npm run dev`: Start the Vite development server.\n- `npm run build`: Build for production.\n- `npm run preview`: Preview the production build locally.\n- `npm test`: Run tests.\n- `npm run lint`: Run linter.\n- `npm run format`: Format code.\n\n## Project Structure\n\nConsider a monorepo structure (e.g., using `pnpm workspaces`, `yarn workspaces`, or `Nx`) or separate repositories. Below are typical structures for each part.\n\n### Backend Structure (Node.js/Express.js)\n\n```\nbackend/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 api/                # API routes and controllers\n\u2502   \u2502   \u251c\u2500\u2500 v1/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 auth/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 auth.controller.ts\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 auth.routes.ts\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 auth.service.ts\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 users/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 customers/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts    # Main v1 router\n\u2502   \u2502   \u2514\u2500\u2500 index.ts        # Main API router\n\u2502   \u251c\u2500\u2500 config/             # Configuration files (db, cors, etc.)\n\u2502   \u251c\u2500\u2500 constants/          # Project-wide constants\n\u2502   \u251c\u2500\u2500 DTOs/               # Data Transfer Objects (for request/response validation)\n\u2502   \u251c\u2500\u2500 enums/              # Enumerations\n\u2502   \u251c\u2500\u2500 interfaces/         # TypeScript interfaces\n\u2502   \u251c\u2500\u2500 jobs/               # Background jobs (e.g., cron jobs)\n\u2502   \u251c\u2500\u2500 lib/                # Shared libraries/utilities\n\u2502   \u251c\u2500\u2500 middlewares/        # Custom Express middlewares\n\u2502   \u251c\u2500\u2500 models/             # Database models (if not using Prisma schema directly)\n\u2502   \u251c\u2500\u2500 services/           # Business logic services (reusable across controllers)\n\u2502   \u251c\u2500\u2500 types/              # Custom TypeScript types\n\u2502   \u251c\u2500\u2500 utils/              # Utility functions\n\u2502   \u251c\u2500\u2500 app.ts              # Express application setup\n\u2502   \u2514\u2500\u2500 server.ts           # Server initialization\n\u251c\u2500\u2500 prisma/                 # Prisma schema and migrations (if using Prisma)\n\u2502   \u251c\u2500\u2500 schema.prisma\n\u2502   \u2514\u2500\u2500 migrations/\n\u251c\u2500\u2500 tests/                  # Test files (unit, integration)\n\u2502   \u251c\u2500\u2500 integration/\n\u2502   \u2514\u2500\u2500 unit/\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 .env.example\n\u251c\u2500\u2500 .eslintrc.js\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 .prettierrc.js\n\u251c\u2500\u2500 nodemon.json            # (Optional) Nodemon configuration\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 tsconfig.json\n\u2514\u2500\u2500 README.md               # Backend specific README\n```\n\n### Frontend Structure (React/Vite)\n\n```\nfrontend/\n\u251c\u2500\u2500 public/                 # Static assets\n\u2502   \u2514\u2500\u2500 index.html\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 assets/             # Images, fonts, etc.\n\u2502   \u251c\u2500\u2500 components/         # Reusable UI components\n\u2502   \u2502   \u251c\u2500\u2500 common/         # Generic components (Button, Input, Modal)\n\u2502   \u2502   \u2514\u2500\u2500 layout/         # Layout components (Navbar, Sidebar, Footer)\n\u2502   \u251c\u2500\u2500 config/             # Frontend configuration (e.g., API endpoints)\n\u2502   \u251c\u2500\u2500 constants/          # Frontend constants\n\u2502   \u251c\u2500\u2500 contexts/           # React Context API providers\n\u2502   \u251c\u2500\u2500 features/           # Feature-based modules (e.g., customers, dashboard)\n\u2502   \u2502   \u2514\u2500\u2500 customers/\n\u2502   \u2502       \u251c\u2500\u2500 components/\n\u2502   \u2502       \u251c\u2500\u2500 hooks/\n\u2502   \u2502       \u251c\u2500\u2500 pages/\n\u2502   \u2502       \u251c\u2500\u2500 services/\n\u2502   \u2502       \u251c\u2500\u2500 store/      # Feature-specific state (if using Redux Toolkit slices)\n\u2502   \u2502       \u2514\u2500\u2500 types.ts\n\u2502   \u251c\u2500\u2500 hooks/              # Custom React hooks\n\u2502   \u251c\u2500\u2500 layouts/            # Page layouts\n\u2502   \u251c\u2500\u2500 lib/                # Shared libraries/utilities (e.g., API client)\n\u2502   \u251c\u2500\u2500 pages/              # Top-level page components\n\u2502   \u251c\u2500\u2500 routes/             # Routing configuration (e.g., using React Router)\n\u2502   \u251c\u2500\u2500 services/           # API service calls\n\u2502   \u251c\u2500\u2500 store/              # Global state management (e.g., Redux store, Zustand store)\n\u2502   \u251c\u2500\u2500 styles/             # Global styles, theme\n\u2502   \u251c\u2500\u2500 types/              # TypeScript type definitions\n\u2502   \u251c\u2500\u2500 utils/              # Utility functions\n\u2502   \u251c\u2500\u2500 App.tsx             # Main application component\n\u2502   \u2514\u2500\u2500 main.tsx            # Entry point\n\u251c\u2500\u2500 tests/                  # Test files\n\u2502   \u251c\u2500\u2500 __mocks__/\n\u2502   \u2514\u2500\u2500 unit/\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 .env.example\n\u251c\u2500\u2500 .eslintrc.js\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 .prettierrc.js\n\u251c\u2500\u2500 index.html              # Vite entry point\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 tsconfig.json\n\u251c\u2500\u2500 tsconfig.node.json      # Vite specific\n\u251c\u2500\u2500 vite.config.ts\n\u2514\u2500\u2500 README.md               # Frontend specific README\n```\n\n## API Documentation\n\nThe backend API should be documented using OpenAPI (Swagger).\n- **Setup**: Use `swagger-jsdoc` and `swagger-ui-express` to generate and serve API documentation from JSDoc comments in your route files.\n- **Access**: Typically available at `/api-docs` on the backend server.\n- **Best Practice**: Define DTOs (Data Transfer Objects) for request and response bodies and use them in your Swagger definitions for clarity and validation.\n\n## State Management (Frontend)\n\n- **Zustand**: For a lightweight, unopinionated global state.\n- **Redux Toolkit**: For more complex applications requiring a structured approach, middleware, and devtools.\n- **React Context API**: For simpler, localized state sharing within component subtrees.\nChoose based on the complexity and needs of the application. Start simple and scale if necessary.\n\n## Styling (Frontend)\n\n- **Tailwind CSS**: Utility-first CSS framework for rapid UI development.\n  - Setup: `npm install -D tailwindcss postcss autoprefixer && npx tailwindcss init -p`\n  - Configure `tailwind.config.js` and `postcss.config.js`.\n  - Import Tailwind directives in your main CSS file.\n- **Material-UI (MUI)**: Comprehensive library of pre-built React components.\n  - Setup: `npm install @mui/material @emotion/react @emotion/styled`\n- **Styled Components / Emotion**: CSS-in-JS libraries for component-scoped styles.\n\n## Testing\n\n- **Backend (Node.js/Express.js):**\n  - **Unit Tests**: Jest. Test individual functions, modules, services.\n  - **Integration Tests**: Jest + Supertest. Test API endpoints, interactions between modules.\n  - **Coverage**: Aim for high test coverage (e.g., >80%).\n- **Frontend (React):**\n  - **Unit/Integration Tests**: Jest + React Testing Library. Test individual components and their interactions.\n  - **End-to-End (E2E) Tests**: Playwright or Cypress. Test user flows across the application.\n  - **Coverage**: Aim for high test coverage.\n\n## Linting and Formatting\n\n- **ESLint**: For identifying and fixing problems in JavaScript/TypeScript code.\n  - Configure with recommended rule sets (e.g., `eslint:recommended`, `plugin:@typescript-eslint/recommended`, `plugin:react/recommended`, `plugin:react-hooks/recommended`).\n- **Prettier**: For automatic code formatting to ensure consistent style.\n- **Husky & lint-staged**: (Optional but Recommended) To run linters and formatters automatically before commits.\n\n## Environment Variables\n\n- Use `.env` files for local development. **Never commit `.env` files to version control.**\n- Use `.env.example` as a template for required environment variables.\n- In production, manage environment variables through your hosting provider's interface or a secrets management system.\n- **Backend**: Use `dotenv` package.\n- **Frontend (Vite)**: Variables prefixed with `VITE_` are exposed to the client-side code.\n\n## Deployment\n\n- **Backend (Node.js):**\n  - Platforms: Docker containers on AWS (ECS, EKS, App Runner), Google Cloud (Cloud Run, GKE), Azure (App Service, AKS), Heroku, Render, Fly.io.\n  - Process: Build TypeScript to JavaScript, install production dependencies, run the server.\n  - PM2: A process manager for Node.js applications in production.\n- **Frontend (React/Vite):**\n  - Platforms: Static site hosting like Netlify, Vercel, GitHub Pages, AWS S3 + CloudFront, Google Firebase Hosting.\n  - Process: `npm run build` generates static assets in the `dist` folder. Deploy this folder.\n- **CI/CD**:\n  - Use GitHub Actions, GitLab CI, Jenkins, etc., to automate testing, building, and deployment on every push or merge to the main branch.\n\n## Contributing\n\n1.  Fork the repository.\n2.  Create a new feature branch (`git checkout -b feature/your-feature-name`).\n3.  Make your changes.\n4.  Commit your changes (`git commit -m 'Add some feature'`). Use conventional commit messages.\n5.  Push to the branch (`git push origin feature/your-feature-name`).\n6.  Open a Pull Request.\n7.  Ensure all tests pass and code is linted/formatted.\n\n## Best Practices\n\n- **Code Quality**: Write clean, maintainable, and well-documented code.\n- **Security**: Prioritize security in both frontend and backend (input validation, XSS prevention, CSRF protection, secure authentication, dependency vulnerability scanning).\n- **Performance**: Optimize for speed and efficiency (code splitting, lazy loading, memoization, database query optimization).\n- **Accessibility (a11y)**: Ensure the application is usable by people with disabilities.\n- **Scalability**: Design the application with scalability in mind.\n- **Modularity**: Break down the application into smaller, manageable modules/components.\n- **Configuration Management**: Use environment variables for configuration.\n- **Error Handling & Logging**: Implement robust error handling and comprehensive logging.\n- **API Design**: Follow RESTful principles or GraphQL best practices.\n- **Testing**: Write comprehensive tests (unit, integration, E2E).\n- **Version Control**: Follow Git best practices (feature branches, meaningful commits, PRs).\n- **Code Reviews**: Conduct thorough code reviews.\n- **Keep Dependencies Updated**: Regularly update dependencies and audit for vulnerabilities.\n\n## Further Help & Documentation\n\n- [React Documentation](https://react.dev/)\n- [Vite Documentation](https://vitejs.dev/)\n- [Node.js Documentation](https://nodejs.org/en/docs/)\n- [Express.js Documentation](https://expressjs.com/)\n- [NestJS Documentation](https://docs.nestjs.com/)\n- [TypeScript Documentation](https://www.typescriptlang.org/docs/)\n- [Prisma Documentation](https://www.prisma.io/docs/)\n- [Mongoose Documentation](https://mongoosejs.com/docs/)\n- [Zustand GitHub](https://github.com/pmndrs/zustand)\n- [Redux Toolkit Documentation](https://redux-toolkit.js.org/)\n- [React Router Documentation](https://reactrouter.com/)\n- [Tailwind CSS Documentation](https://tailwindcss.com/docs/)\n- [Material-UI Documentation](https://mui.com/material-ui/getting-started/)\n- [Jest Documentation](https://jestjs.io/docs/getting-started)\n- [React Testing Library Documentation](https://testing-library.com/docs/react-testing-library/intro/)\n- [Supertest GitHub](https://github.com/ladjs/supertest)\n- [ESLint Documentation](https://eslint.org/docs/latest/)\n- [Prettier Documentation](https://prettier.io/docs/en/)\n- [Docker Documentation](https://docs.docker.com/)\n- [GitHub Actions Documentation](https://docs.github.com/en/actions)\n\"\"\"", "best_practices": ["Component-Based Architecture (Frontend) & Modular Design (Backend): Promote reusability and maintainability by breaking down the application into smaller, manageable, and independent pieces.", "TypeScript for Type Safety: Utilize TypeScript across both frontend and backend to enhance code quality, improve developer experience with autocompletion, and catch errors early during development.", "Effective State Management (Frontend): Choose an appropriate state management solution for React (e.g., Zustand for simplicity, Redux Toolkit for complex applications, or React Context API for localized state) based on application needs.", "Robust API Design & Security (Backend): Implement secure (e.g., JWT for authentication, input validation, Helmet for security headers, rate limiting) and well-structured APIs (e.g., RESTful principles or GraphQL), documented with OpenAPI/Swagger.", "Comprehensive Testing: Implement a multi-layered testing strategy including unit tests (Jest, React Testing Library for frontend; Jest for backend), integration tests (React Testing Library, Supertest for backend API testing), and consider end-to-end tests (Playwright, Cypress) to ensure application reliability.", "Consistent Code Style & Quality: Enforce a consistent code style using ESLint for linting and Prettier for code formatting. Integrate these tools into pre-commit hooks (e.g., with Husky and lint-staged) to maintain code quality automatically.", "Environment Configuration Management: Manage application configuration using environment variables (e.g., via `.env` files for local development, sourced from the hosting environment in production) to keep sensitive information and environment-specific settings out of the codebase.", "CI/CD Pipelines: Automate the build, test, and deployment processes using CI/CD pipelines (e.g., GitHub Actions, GitLab CI) to ensure rapid and reliable delivery of new features and fixes.", "Version Control with Git: Adhere to Git best practices, including feature branching, writing clear and conventional commit messages, conducting code reviews via Pull Requests, and maintaining a clean project history.", "Performance Optimization & Accessibility (a11y): Proactively optimize application performance (e.g., code splitting, lazy loading in React; efficient database queries, caching in Node.js) and ensure the web application is accessible to all users by following WCAG guidelines."], "suggested_extensions": ["dbaeumer.vscode-eslint", "esbenp.prettier-vscode", "msjsdiag.debugger-for-chrome", "ms-vscode.node-debug2", "eamodio.gitlens", "ms-azuretools.vscode-docker", " Prisma.prisma", "bradlc.vscode-tailwindcss", "mikestead.dotenv", "PKief.material-icon-theme", "Gruntfuggly.todo-tree", "VisualStudioExptTeam.vscodeintellicode", "christian-kohler.path-intellisense", "wix.vscode-import-cost", " Orta.vscode-jest"], "documentation_source": ["React Documentation: https://react.dev/", "Vite Documentation: https://vitejs.dev/", "Node.js Documentation: https://nodejs.org/en/docs/", "Express.js Documentation: https://expressjs.com/", "NestJS Documentation: https://docs.nestjs.com/", "TypeScript Documentation: https://www.typescriptlang.org/docs/", "Prisma Documentation: https://www.prisma.io/docs/", "Mongoose Documentation: https://mongoosejs.com/docs/", "Zustand GitHub: https://github.com/pmndrs/zustand", "Redux Toolkit Documentation: https://redux-toolkit.js.org/", "React Router Documentation: https://reactrouter.com/", "Tailwind CSS Documentation: https://tailwindcss.com/docs/", "Material-UI Documentation: https://mui.com/material-ui/getting-started/", "Jest Documentation: https://jestjs.io/docs/getting-started", "React Testing Library Documentation: https://testing-library.com/docs/react-testing-library/intro/", "Supertest GitHub: https://github.com/ladjs/supertest", "ESLint Documentation: https://eslint.org/docs/latest/", "Prettier Documentation: https://prettier.io/docs/en/", "Docker Documentation: https://docs.docker.com/", "GitHub Actions Documentation: https://docs.github.com/en/actions"], "copilot_instructions": "\"\"\"\n# GitHub Copilot Instructions for crm-webapp (HappyPathway)\n\n## Project Overview\nYou are assisting in the development of a CRM web application named \"crm-webapp\" for HappyPathway.\nThe frontend is built with React (using Vite and TypeScript) and the backend with Node.js (using Express.js/NestJS and TypeScript).\n\n## General Instructions\n- Prioritize TypeScript for all new code.\n- Follow RESTful API design principles for the backend.\n- Ensure code is well-commented, especially for complex logic.\n- Write unit and integration tests for new features.\n- Adhere to ESLint and Prettier configurations for code style.\n- Use environment variables for configuration (e.g., API keys, database URLs).\n- Focus on security best practices (input validation, output encoding, authentication).\n\n## Frontend (React with Vite & TypeScript)\n- **Component Structure**: When creating components, follow a clear structure (e.g., `src/components/feature/MyComponent.tsx`).\n- **State Management**:\n    - For local component state, use `useState` and `useReducer`.\n    - For global state, we are considering Zustand or Redux Toolkit. If a feature requires global state, ask for clarification or start with Zustand for simplicity unless a more complex setup like Redux Toolkit is explicitly requested for that feature.\n    - For cross-cutting concerns that don't fit global state, use React Context.\n- **Hooks**: Create custom hooks (`useFeatureName`) for reusable logic.\n- **Styling**: We are using Tailwind CSS (or Material-UI, confirm project choice). Generate utility classes or styled components accordingly.\n- **API Calls**: Use Axios for API calls. Create service functions in `src/services/` to encapsulate API interactions.\n    - Example: `// Create a function to fetch customer data from the backend API /api/v1/customers`\n- **Routing**: Use React Router v6 for navigation.\n    - Example: `// Create a new route for the customer details page at /customers/:id`\n- **Forms**: Use libraries like React Hook Form for form handling and validation.\n- **Testing**: Use Jest and React Testing Library.\n    - Example: `// Write a test for the LoginForm component to check for successful login.`\n- **TypeScript**: Define clear types and interfaces for props, state, and API responses.\n    - Example: `// Define a TypeScript interface for a Customer object.`\n\n## Backend (Node.js with Express.js/NestJS & TypeScript)\n- **Framework Choice**: The project might use Express.js or NestJS. Adapt suggestions accordingly. If NestJS, leverage its modules, controllers, services, and DI.\n- **API Endpoints**:\n    - Version APIs (e.g., `/api/v1/resource`).\n    - Use standard HTTP methods (GET, POST, PUT, DELETE, PATCH).\n    - Example: `// Create an Express route for POST /api/v1/customers to add a new customer.`\n    - Example: `// Create a NestJS controller method for GET /api/v1/users/:id.`\n- **Controllers**: Keep controllers lean, delegating business logic to services.\n- **Services**: Implement business logic in service classes/modules.\n- **Database Interaction**: We are using Prisma or Mongoose.\n    - Example (Prisma): `// Write a Prisma query to find a user by email.`\n    - Example (Mongoose): `// Define a Mongoose schema for a Product.`\n- **Authentication**: Use JWT for authentication. Implement middleware for protecting routes.\n    - Example: `// Create an Express middleware to verify JWT tokens.`\n- **Validation**: Use libraries like `class-validator` and `class-transformer` (especially with NestJS) or `express-validator` for request body validation.\n    - Example: `// Add validation for the customer creation DTO: name (string, required), email (email, required).`\n- **Error Handling**: Implement centralized error handling middleware.\n- **Logging**: Use a structured logger like Winston or Pino.\n    - Example: `// Add a log statement for when a new user registers.`\n- **Testing**: Use Jest and Supertest for API endpoint testing.\n    - Example: `// Write an integration test for the POST /api/v1/auth/login endpoint.`\n- **DTOs**: Use Data Transfer Objects for request and response payloads.\n\n## Specific Task Prompts for Copilot:\n- `// Generate a React functional component for a customer list item with props: id, name, email, phone.`\n- `// Create an Express.js route handler for GET /api/v1/customers/:id that fetches a customer by ID using Prisma.`\n- `// Implement a Node.js service function to create a new user, hash their password using bcrypt, and save to the database using Prisma.`\n- `// Write a React custom hook 'useFetchCustomers' that fetches customer data from '/api/v1/customers' using Axios and handles loading/error states.`\n- `// Define a TypeScript interface for API responses containing a 'data' field and an optional 'error' field.`\n- `// Set up basic ESLint and Prettier configuration for a TypeScript project.`\n- `// Create a Dockerfile for a Node.js Express application.`\n- `// Create a GitHub Actions workflow to run tests on push to main branch for the backend.`\n\nRemember to ask for clarification if the context is ambiguous.\nPrioritize creating secure, efficient, and maintainable code.\n\"\"\""}